<!doctype html><html><head>    <meta charset="utf-8">    <meta http-equiv="X-UA-Compatible" content="chrome=1">    <title>Remoting by gzoritchak</title>    <link rel="stylesheet" href="stylesheets/styles.css">    <link rel="stylesheet" href="stylesheets/pygment_trac.css">    <script src="javascripts/scale.fix.js"></script>    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">    <!--[if lt IE 9]>    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>    <![endif]--></head><body><div class="wrapper">    <header>        <h1 class="header">Remoting</h1>        <p class="header"></p>        <ul>            <li class="download"><a class="buttons" href="https://github.com/gzoritchak/remoting/zipball/master">Download                ZIP</a></li>            <li class="download"><a class="buttons" href="https://github.com/gzoritchak/remoting/tarball/master">Download                TAR</a></li>            <li><a class="buttons github" href="https://github.com/gzoritchak/remoting">View On GitHub</a></li>        </ul>        <br><a href="index.html">Introduction</a>        <br><a href="architecture.html">Architecture</a>        <br><a href="authentication.html">Authentication</a>        <br><a href="deployment.html">Packaging</a>        <br><a href="using.html">How to use it?</a>        <br><a href="javadoc/index.html">Javadoc</a>        <br>        <br>        <p class="header">This project is maintained by <a class="header name" href="https://github.com/gzoritchak">gzoritchak</a>        </p>    </header>    <section>    <h2>Overview</h2>    The Remoting is based on server and client classes.    <h3>On the client</h3>    <p>        On this tier, the goal is to transparently encapsulate the client calls in        HTTP. This is done with the use of Dynamic Proxies. They allow a class to        implements interfaces specified at runtime when the class is created. This        feature is perfect for our goal because all the remote invocations on EJBs        are based on interfaces.    </p>    <p>        The client sees its remote interface but in reality it is an instance of        HttpServiceInvocationHandler that receives the method calls. This class        then delegates the calls to the HttpSessionClient.    </p>    <h4>Configuration</h4>    <p>        The client sets the config parameters of the client session        by calling few method on the HttpServiceFactory :    </p><pre>    HttpServiceFactory factory = new HttpServiceFactory();    factory.setPort(8080);    factory.setContext("myApp");    factory.setHost("localhost");</pre>    <p>        These parameters are then used by the HttpSessionClient to process the HTTP        requests    </p>    <h4>Interaction diagram</h4>    <img src="remoting-client-side.png" alt="Client side architecture"/>    <p>        To retrieve a reference on a EJB interface, the client asks it to the        HttpServiceFactory :    </p><pre>    MyService myService = factory.getService(new EJBDefinition(                            "ejb/myJndiName", "test.MyServiceHome",                            "test.MyService"));</pre>    <p>        The constructor of the EJBDefinition takes the jndi name, the home class name and        the remote class name as parameters. They are used on the server side to perform        the lookup and the narrowing.    </p>    <p>        The HttpServiceFactory use the remote class to create a dynamic proxy implementing        it. The client sees a remote interface of an EJB. When the client make a call on        this interface, the method and the parameters of the call are transmitted to the        HttpServiceInvocationHandler which delegates the call to the HttpSessionClient.    </p>    <p>        This class is responsible for the HTTP stuff. It maintains the session with the        server using url rewriting. It serializes the call as an Object Stream into the        http stream and handle the response. When the response is another EJB (for instance        a reference on statefull EJB) the object sent back by the server is an instance of        HttpServiceKey. The HttpSessionClient then creates a new dynamic proxy for the client        that implements the new EJB. In case of a serialized object or exception        the client receives it normally.    </p>    <h3>On the server</h3>    <img src="remoting-server-side.png" alt="Server side architecture"/>    <p>        The HttpSessionServer servlet is responsible for handling the client calls.    </p>    <p>        It creates a session at first call. The session id is return to the client using        the jsessionid HTTP header.    </p>    <p>        The HttpSessionServer uses the EJBDefinition to lookup the EJBHome on the InitialContext        and create an EJB. It always uses a create method without argument.    </p>    <p>        Then it invocates the call using reflection. The result is sent back to the client using        the HttpOutputStream. If the result is another session EJB (stateful or stateless) the        reference on that EJB is kept in the user session and a HttpServiceKey is returned back        to the client. The HttpClientSession handles that key to creates the awaiting interface.    </p>    <p>    </p>        </section></div><!--[if !IE]><script>fixScale(document);</script><!--<![endif]--></body></html>